---
description: https://asfirstalways.tistory.com/158
---

# JAVA

### JVM이란?

* JVM 역할은 자바 애플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행하는 것
* JVM과 OS사이에서 **중계자 역할**을 수행하여 JAVA가 OS에 구애받지 않고 재사용을 가능하게 해줌
* 메모리관리, Garbage collection을 수행 &#x20;
* 스택기반의 가상머신



### JAVA 프로그램 실행과정

1.  프로그램이 실행되면 JVM은 OS로부터 이 프로그램이 필요로 하는 메모리를 할당받는다.

    JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.
2. 자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어들여 자바 바이트코드(.class)로 변환시킨다.
3. Class Loader를 통해 class파일들을 JVM으로 로딩한다.
4. 로딩된 class파일들은 Execution engine(실행엔진   )을 통해 해석된다.
5.  해석된 바이트코드는 Runtime Data Areas 에 배치되어 실질적인 수행이 이루어지게 된다.

    이러한 실행과정 속에서 JVM은 필요에 따라 Thread Synchronization과 GC같은 관리작업을 수행



### **가비지 컬렉션이란?**

정리되지 않은 메모리, 유효하지 않은 메모리 주소인 가비지를 정리해주는 프로그램



### **벡터와 어레이리스트의 차이는?**

* **Vector**: 동기식. 한 스레드가 Vector 작업중이면 다른 스레드가 Vector 보유할 수 없음.&#x20;
* **ArrayList**: 비동기식. 여러 스레드가 ArrayList에서 동시에 작업할 수 있음.



### **String과 StringBuffer의 차이**

* (**String**) 불변. 문자를 수정하려면 지우고 다시 생성(new) -> 문자열 연산이 많으면 성능 떨어짐
* (**StringBuffer**) 가변. 한번 만들고 필요할 때 크기를 변경하여 문자를 변경. append()처럼.
* (**StringBuilder**) 동기화 지원x, 멀티쓰레드 환경에부적합. => 싱글쓰레드에서 stringBuffer 보다 좋음



### **java의 메모리영역**

* **메소드 영역 / 스택 영역 / 힙 영역**&#x20;
* (메소드) 바이트 코드와 전역변수, static변수&#x20;
* (스택) 매개변수, 지역변수 / 사용이 끝나면 바로 소멸됨. 컴파일 시 메모리 할당&#x20;
* (힙) new로 생성된 객체 / 호출이 끝나도 사라지지 않으며 프로그램 실행 시 동적으로 할당



### **오버로딩과 오버라이딩의 차이**

*   (**오버로딩**) 메소드의 이름은 하나이고, 매개변수를 다르게 함으로써 메소드를 여러 개 만드는 것.&#x20;


* (**오버라이딩**) 자바에서 부모클래스로부터 상속받은 메소드를 재정의 하는 것.&#x20;
  * 오버라이딩 된 메소드는 부모클래스의 메소드보다 우선되어 자식 객체에서 호출 시 오버라이딩 된 메소드가 호출됨.&#x20;
  * 원래 메소드와 동일한 리턴타입, 메소드이름, 매개변수 리스트를 가져아함.



### **추상클래스와 인터페이스 차이**

* (**추상 클래스**) 클래스 내 추상 메소드가 하나 이상 포함되거나 abstract로 정의된 경우.그 추상클래스를 상속받아서 기능을 이용하고 확장하도록 함 (extends)
* (**인터페이스**) 모든 메소드가 추상 메소드인 경우. 여러 개 implements가 가능하므로 다중 상속 구현 가능함수의 껍데기만 있는 뼈대의 의미, 구현하는 모든 클래스에 대해 그 함수의 구현을 강제적으로 하도록 함.



### **제네릭이란?**

* 클래스에서 사용할 타입을 클래스 외부에서 설정하는 것.&#x20;
* 만들어져 있는 클래스를 내가 원하는 형태로 사용할 수 있음.&#x20;
* < > 안에 들어갈 수 있는 것은 참조자료형(클래스, 인터페이스, 배열) 뿐.&#x20;
* 기본자료형을 사용하기 위해선 wrapper 클래스를 이용해야 함.



### **객체지향의 특징**

*   (**다형성**) 하나의 메소드나 클래스가 다양한 방법으로 동작하는 것.&#x20;

    * 예) 오버로딩과 오버라이딩상속을 통해 기능을 확장하거나 변경하는 것을 가능하게 해 주고,&#x20;
    * 같은 클래스 내의 코드 길이를 줄여줌


*   (**상속**) 공통적으로 필요한 성격을 가장 기본적인 클래스로 정의해두고, 상속받아 사용. 중복 최소화


* (**캡슐화**)&#x20;
  * public, protected, private라는 접근 지정자를 통해 클래스에 담는 내용 중 중요한 데이터나 기능을 외부에서 접근하지 못하도록 함.&#x20;
  * 객체 외부에서는 내부 정보를 직접 접근하거나 조작할 수 없음, getter 와 setter를 통해서만 접근 가능.\


### **접근 지정자**

* (**public**) 모든 접근을 허용함.
* (**protected**) 상속받은 클래스 또는 같은 패키지에서만 접근 가능
* (**default**) 기본 제한자, 자신 클래스 내부와 같은 패키지 내에서만 접근 가능
* (**private**) 외부에서 접근 불가능, 같은 클래스 내에서만 가능



### **값에 의한 호출, 레퍼런스에 의한 호출**

* (**Call by value**) 값을 복사해서 새로운 함수로 넘기는 호출 방식. 원본의 값이 변경되지 않는다.
* (**Call by reference**) 주소 값을 인자로 전달하는 호출 방식. 원본의 값이 변경된다.



### **링크드리스트, 배열의 차이점**

*   (**배열**)&#x20;

    * 인덱스를 가짐
    * 원하는 데이터를 한번에 접근하여 접근 속도가 빠름. 크기 변경 불가.&#x20;
    * 데이터를 삽입, 삭제 후 그 위치의 다음위치부터 모든 데이터의 위치를 변경해야하는 단점.&#x20;


* (**연결리스트**)
  * &#x20;인덱스 대신 현재 위치의 이전/ 다음 위치를 기억.
  * 크기가 가변적.한번에 접근 불가
  * 연결되어 있는 링크를 따라가야 접근 가능하여 배열에 비해 속도가 떨어짐.
  * 데이터 삽입/삭제는 논리적 주소만 바꿔주기 때문에 용이함.&#x20;
    * 데이터 양이 많지만 삽입/삭제 없으며,&#x20;
    * 데이터 접근이 빈번할 때 (배열 추천)데이터 양이 적고,&#x20;
    * 삽입/삭제가 빈번할 때 (링크드리스트 추천)



### **MVC 패턴이란**

*   어플리케이션을 3가지 역할로 구분한 것(Model, View, Controller)&#x20;

    * 사용자가 컨트롤러를 조작하면, 컨트롤러는 모델을 통해 데이터를 가져옴.&#x20;
    * 그 정보를 바탕으로 시각적인 표현을 담당하는 뷰를 제어하여 사용자에게 전달하는 방법.


* (**장점**) 코드의 가독성, 확장성, 유지보수성을 늘릴 수 있고 코드의 중복을 최소화
* (**단점**) 설계 시간이 오래걸리고 숙련된 개발자가 필요하며, model과 view의 완벽한 분리가 어렵다(의존적)



### JDBC란?

* (Java Database Connectivity) java에서 DB에 접근하여 (작업) 데이터를 조회/삽입/수정/삭제 가능 => 연결해주는 응용프로그램 인터페이스인 JAVA API. DBMS 종류에 따라 그에 맞는 jdbc를 설치
